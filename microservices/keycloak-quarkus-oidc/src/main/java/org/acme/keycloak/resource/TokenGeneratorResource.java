package org.acme.keycloak.resource;

import io.netty.handler.codec.http.HttpResponseStatus;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.MediaType;
import lombok.extern.slf4j.Slf4j;
import org.acme.keycloak.domain.Token;
import org.acme.keycloak.response.BaseResponse;
import org.acme.keycloak.response.TokenResponse;
import org.acme.keycloak.restclient.KeyCloakClient;
import org.eclipse.microprofile.openapi.annotations.enums.ParameterIn;
import org.eclipse.microprofile.openapi.annotations.enums.SchemaType;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.parameters.Parameter;
import org.eclipse.microprofile.openapi.annotations.parameters.Parameters;
import org.eclipse.microprofile.rest.client.inject.RestClient;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

import static org.acme.keycloak.constants.MessagingConstants.SUCCESS_MSG;

/**
 * @author irfan.nagoo
 */

@Path("/access-token")
@ApplicationScoped
@Slf4j
public class TokenGeneratorResource {

    @RestClient
    private KeyCloakClient keyCloakClient;

    /**
     * This is a convenience REST API to generate JWT token with access code. This REST
     * API used client_credentials as Oauth2.0 grant type generally recommended for
     * microservices and other internal applications.
     *
     * @param httpHeaders - 1. clientId - Client ID of the client as configured in Oauth2.0 server.
     *                    <br>2. secret - Client secret as generated by Oauth2.0 server.
     * @return
     */
    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/generate")
    @Parameters({
            @Parameter(in = ParameterIn.HEADER, required = true, name = "clientId", schema = @Schema(type = SchemaType.STRING)),
            @Parameter(in = ParameterIn.HEADER, required = true, name = "secret", schema = @Schema(type = SchemaType.STRING))
    })
    public Uni<BaseResponse> generateAccessToken(HttpHeaders httpHeaders) {
        log.info("generateAccessToken: Start");
        String clientId = httpHeaders.getHeaderString("clientId");
        String secret = httpHeaders.getHeaderString("secret");
        Uni<Token> token = keyCloakClient.getAccessToken("grant_type=client_credentials", getAuthorization(clientId, secret));
        return buildResponse(token);
    }

    private static String getAuthorization(String clientId, String secret) {
        return "Basic " + Base64.getEncoder()
                .encodeToString((clientId + ":" + secret).getBytes(StandardCharsets.UTF_8));
    }

    private static Uni<BaseResponse> buildResponse(Uni<Token> token) {
        return Uni.combine().all()
                .unis(token)
                .usingConcurrencyOf(1)
                .combinedWith(tokenList -> new TokenResponse(HttpResponseStatus.OK.reasonPhrase(),
                        SUCCESS_MSG, (Token) tokenList.get(0)));
    }

}
